\chapter{Composing a solver}
\label{chapter:composingats}
\smtrat contributes a toolbox for composing an SMT compliant solver for real arithmetic, that means it 
is incremental, supports backtracking and provides reasons for inconsistency. The resulting
solver is either a fully operative SMT solver for real arithmetic, which can be applied
directly on \texttt{.smt2}-files, or a theory solver, which can be embedded into an SMT 
solver in order to extend its supported logics by real arithmetic.

We are talking about composition and toolbox, as \smtrat contains implementations
of many different mathematical approaches to tackle real arithmetic, each of them
embedded in a module with uniform interfaces. Theses modules form the tools in the toolbox
and it is dedicated to a user how we use them for solving a real arithmetic formula.
We provide a self-explanatory graphical user interface (GUI) for defining a graph-based 
\emph{strategy} specifying which module(s) should be applied on which formula, 
taking into account the modules we have already involved.

In the following of this chapter we firstly give a formal definition of 
a strategy, followed by a brief introduction to the existing modules equipped
with an estimation of their input-based performances. Afterwards we illustrate
how to use the GUI for composing a strategy.

\section{The strategy}
For the comprehension of this section we presume the reader to be familiar with the
concept of \texttt{runBackends(..)}, which we introduced in Chapter~\ref{chapter:implementingamodul}.

From the viewpoint of a user, who composes a solver with \smtrat, the composition starts solving a real 
arithmetic formula $\varphi$ by invoking a consistency check of a module $M$ on $\varphi$. Most of
the modules simplify $\varphi$ to an equisatisfiable real arithmetic formula $\varphi'$ or need to 
know the consistency of a real arithmetic subproblem $\varphi'$, which it cannot
solve itself. In that case, $M$ calls \texttt{runBackends(..)}, which runs the consistency 
check of a backend module $M'$ on $\varphi'$. The strategy specifies $M'$ according to, firstly,
the structure of $\varphi'$ and, secondly, the call hierarchy of the consistency checks of modules
leading to this request. 

Therefore, the strategy is a directed tree $T:=(V, E)$ with a set $V$ of module instances as nodes and $E\subseteq V\times \Omega\times V$, where $\Omega$ is a set of conditions on real arithmetic formulas. Initially, the method \texttt{isConsistent($\varphi_{rcv}$)} of the module instance given by the root of the strategy is called, where $\varphi_{rcv}$ is a conjunction of real arithmetic formulas. Whenever a module instance $m\in V$ calls \texttt{runBackends($\varphi_{pass}$)}, \texttt{isConsistent($\varphi_{pass}$)} of each module $m'$ is called, for which an edge $(m, \omega, m')\in E$ exists such that $\omega$ holds for $\varphi_{pass}$, and passes the results back to $m$. A condition on real arithmetic formulas are
arbitrary Boolean combinations of properties of a real arithmetic formula as follows.
\begin{itemize}
	\item Propositions about the Boolean structure of the formula. In our case it is
		always a conjunction of positive literals, e.g. whether it is a conjunction of
		real arithmetic constraints only or whether it is in conjunctive normal form.
	\item Propositions about the constraints in the formula, e.g. whether the formula contains (does not contain)
		(only) equations/(strict inequalities).
	\item Propositions about the polynomials compared by the constraints, e.g., whether they are 
		linear, univariate, contain more than $n$ variables or have a degree smaller than $k$.
\end{itemize}

%Usually, the root module \CNFM transforms its set of received formulas $\varphi_{rcv}^{cnf}$ to an equisatisfiable set of clauses $\varphi_{pass}^{cnf}$ and calls \texttt{runBackends($\varphi_{pass}^{cnf}$)}. The backend is a SAT-solver module \SATM, which runs DPLL-style SAT-solving on the Boolean abstraction of the set of received clauses $\varphi_{rcv}^{sat}$. \SATM might call \texttt{runBackends($\varphi_{pass}^{sat}$)} for partial Boolean assignments on the corresponding set of formulas $\varphi_{pass}^{sat}$; we refer to such a backend call as \emph{theory call}. The Boolean abstraction of the obtained infeasible subsets and lemmas are stored as additional clauses. Infeasible subsets and lemmas, which contain only formulas from $\varphi_{pass}^{sat}$, prune the Boolean search space and hence the number of theory calls. Smaller infeasible subsets are usually more advantageous, because they make larger cuts in the search space. Other types of lemmas contain new formulas, so-called \emph{inventive lemmas} (\emph{non-inventive} otherwise) and might enlarge the Boolean search space, but they can reduce the complexity of later theory calls. This way we can compose SMT solvers for RCF, e.g., using the simple strategy defined by the nodes $I_{\CNFM}$, $I_{\SATM}$ and $I_{\CADM}$ 
%and the edges $(I_{\CNFM}, I_{\SATM})$ and $(I_{\SATM}, I_{\CADM})$.

\section{Specifying a strategy with the GUI}




