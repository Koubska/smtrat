\chapter{Further features}
\label{chapter:further_features}

\section{Delta debugging}
\emph{Delta debugging} describes a generic debugging approach based on automated testing.
Given a program and an input that provokes a certain behaviour -- for example an error -- delta debugging is the process of iteratively changing the input, retaining the specific behaviour.
Each small change to the input represents a \emph{delta} the name refers to and is the result of some \emph{transformation rule}.
Whenever a change was successful, the change is stored and the process continues from this new changed input.
Eventually, there is no transformation left, such that the faulty behaviour is retained and the debugging process terminates.

This approach only works, if the transformation rules can neither be chained to form a loop, nor continue infinitely.
Usually, as the ultimate goal is a minimal example that triggers some bug, all transformation rules are designed to make the input \emph{smaller}, in one way or another.

As this approach has proven to be very valuable in the context of SMT solving, but existing delta debugging tools seemed to be suboptimal to us, SMT-RAT provides its own delta debugging tool \texttt{delta} which can be used completely independent of SMT-RAT.
\texttt{delta} is built to be as generic as possible, but focuses on programs operating on SMTLib files.
It has knowledge of the semantics or logics, but only operates on nodes. Any SMTLib construct, that is either a constant or a braced expression, is a node.

The actual transformation rules are implemented in \texttt{operations.h} and are enabled in the constructor of the \texttt{Producer} class.
The implemented rules are rather simple: removing a node, replacing a node by a child node, simplifying a number, replacing a symbol by a constant or eliminating a let expression.
These transformations are designed such that they can be extended easily.
For a given input \texttt{delta} applies each transformation to each node.
Each application may product arbitrarily many \emph{candidate inputs}, that are then tested. The first candidate that provokes the error is then adopted, the other candidates are rejected.

When analyzing the behaviour, \texttt{delta} relies on the exit code of the program.
It will run the program on the original input and obtain the \emph{original exit code}.
Whenever the program returns the same exit code, \texttt{delta} assumes that the program behaved the same.
Hence, if you want to debug a specific assertion (or error, faulty output, ...), make sure that this event results in a unique exit code.

Using \texttt{delta} is rather easy.
It accepts the input file and the solver as its two main arguments: \texttt{./delta -i input.smt2 -s ./solver}.
There are a couple of other arguments that are documented in the help: \texttt{./delta --help}.
