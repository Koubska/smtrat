\chapter{Implementing further modules}
\label{chapter:implementingamodule}
In this chapter we explain how to implement further modules. A module is a derivation
of the class \texttt{Module} and we give an 
introduction to its members, interfaces and auxiliary methods in the following of this
chapter. A new module and, hence, the corresponding \Cpp source and header files can be easily
created when using the script \writeModule. Its single argument is the module's name
and the script creates a new folder in \texttt{src/lib/modules/} containing the
source and header file with the interfaces yet to implement. Furthermore, it is optional to create the
module having a template parameter forming a settings object as explained in Section~\ref{sec:auxfunctions}.
A new module should be created only this way, as the script takes care of a correct integration of the corresponding code
into \smtrat.

\section{Main members of a module}
Here is an overview of the most important members of the class \texttt{Module}.
\begin{itemize}
	\item \begin{verbatim}vector<PointerSet<Formula>> mInfeasibleSubsets\end{verbatim}
		Stores the infeasible subsets of the so far received formulas, if the module determined that
		their conjunction is not satisfiable.
	\item \begin{verbatim}Manager* const mpManager\end{verbatim}
		A pointer to the manager which maintains the allocation of modules (including this one) to other 
		modules, when they call a backend for a certain formula. For further details see Chapter~\ref{chapter:composingats}.
	\item \begin{verbatim}ModuleInput* mpReceivedFormula\end{verbatim}
		The \emph{received formula} stores the conjunction of the so far received formulas, which this module considers
		for a satisfiability check. These formulas are of the type \formulaClass and the \moduleInputClass
		is basically a list of such formulas, which never contains a formula more than once.
	\item \begin{verbatim}ModuleInput* mpPassedFormula\end{verbatim}
		The \emph{passed formula} stores the conjunction of the formulas which this module passes to a backend to be
		solved for satisfiability.
\end{itemize}
Note that the received formula of a module is the passed formula of the preceding module. The owner is the preceding module, hence, a module has only read access to its received formula. The \moduleInputClass also stores a mapping of
a sub-formula in the passed formula of a module to its origins in the received formula of the same module. Why this mapping
is essential and how we can construct it is explained in Section~\ref{sec:runbackend}.

\section{Interfaces to implement}
In the following we explain which interfaces must be implemented in a module.

\subsection{Informing about a constraint}
\begin{figure}[htb]
\label{fig:exa_inform}
\caption{Example showing how to implement the method \texttt{inform}}
\begin{verbatim}
	bool MyModule::inform( const Formula* _constraint )
	{
	    // Write the implementation here.
	}
\end{verbatim}
\end{figure}
Informs the module about the existence of the given constraint (actually it is a
formula wrapping a constraint) usually before it is actually added to this module for consideration
of a later satisfiability check. At least it can be expected, that this method
is called, before a formula containing the given constraint is added 
to this module for consideration of a later satisfiability check. 
Note that this information might be useful for the module, e.g., for the 
initialization of the data structures it uses. If the module
can already decide whether the given formula is not satisfiable itself, it returns \false
otherwise \true.

\subsection{Asserting a received formula}
\begin{figure}[htb]
\label{fig:exa_assertsubformula}
\caption{Example showing how to implement the method \texttt{assertSubformula}}
\begin{verbatim}
	bool MyModule::assertSubformula( const ModuleInput::const_iterator _subformula )
	{
	    Module::assertSubformula( _subformula );
	    // Write the implementation here.
	}
\end{verbatim}
\end{figure}
Asserts the formula at the given position in the conjunction of received formulas 
(\texttt{mpReceivedFormula}), meaning that this module has to include this formula
in the next satisfiability check. If the module
can already decide (with a very low effort) whether the given formula is not satisfiable in combination
with the already received formulas, it returns \false otherwise \true. This could be determined based on 
solving results this module has stored after the last consistency checks. 
Note, that the implementation of a new module might need some initialization in this method
and has always to call \texttt{Module::assertSubformula} at the beginning.

\subsection{Removing a received formula}
\begin{figure}[htb]
\label{fig:exa_removesubformula}
\caption{Example showing how to implement the method \texttt{removeSubformula}}
\begin{verbatim}
	void MyModule::removeSubformula( const ModuleInput::iterator _subformula )
	{
	    // Write the implementation here.
	    Module::removeSubformula( _subformula );
	}
\end{verbatim}
\end{figure}
Removes the formula at the given position from the received formula
(\texttt{mpReceivedFormula}). Everything,
which has been stored in this module and depends on this formula must be removed. In the end of
this method, \texttt{Module::removeSubformula} must be called. This handles the removing of everything
depending on this formula in the backends of this module, including the infeasible subsets and
the passed formula. Hence, there is no need to take care of this.

\subsection{Checking for satisfiability}
\begin{figure}[htb]
\label{fig:exa_check}
\caption{Example showing how to implement the method \texttt{check}}
\begin{verbatim}
	Answer MyModule::check()
	{
	    // Write the implementation here.
	}
\end{verbatim}
\end{figure}
Implements the actual satisfiability check of the conjunction of formulas, which have been asserted in this module.
There are three options how this module can answer: it either determines that the formulas
are satisfiable and returns \True, it determines unsatisfiability and returns
\False, or it cannot give a conclusive answer and returns \Unknown. Note, that the method \texttt{Answer foundAnswer( Answer )} must
be invoked with the found answer, before return it. Its return value has the same value as its argument and, hence, 
can be called the following way:
\begin{verbatim}
Answer MyModule::check()
{
    ...
    return foundAnswer( yourAnswer );
}
\end{verbatim}
Furthermore, modules can always call
a backend in order to check the satisfiability of any conjunction of formulas. How to run the backend is shown in
Section~\ref{sec:runbackend}. A module has also the opportunity to reason about the conflicts
occurred, if it determines unsatisfiability. For this purpose it has store at least one infeasible
subsets of the set of so far received formulas.

\section{Running backend modules}
\label{sec:runbackend}
Modules can always call a backend in order to check the satisfiability of any conjunction of formulas.
Fortunately, there is no need to manage the assertion of formulas to or removing of formulas from the backend. 
This would be even more involved as we do allow changing the
backend if it is appropriate (more details to this are explained in Chapter~\ref{chapter:composingats}).
Running the backend is done in two steps:
\begin{enumerate}
	\item Change the passed formula to the formula which should be solved by the backend. Keep in mind,
	       that the passed formula could still contain formulas of the previous backend call.
	\item Call \texttt{runBackends()}.
\end{enumerate}
The first step is a bit more tricky, as we need to know which received formulas led to a passed
formula. For this purpose the \moduleInputClass maintains a mapping from a passed sub-formula to one or more
sets of received sub-formulas. We give a small example. Let us assume that a module has so far received the following
constraints (wrapped in formulas)
$$c_0:x\leq0,\ c_1:x\geq 0,\ c_2:x=0$$
and combines the first two constraints $c_0$ and $c_1$ to $c_3:x=0$. Then it combines
$c_3$ with $c_2$ to $c_5:x=0$. Afterwards it calls its backend on the only remaining constraint,
that means the passed formula contains only $c_5:x=0$. The mapping of $c_5$ to the received sub-formulas it
stems from is $$c_5\ \mapsto\ (\{c_0,\ c_1\},\ \{c_2\}).$$

The mapping is maintained automatically and offers two methods to add formulas to the vector
of the passed formulas:
\begin{itemize}
	\item \begin{verbatim}
		std::pair<ModuleInput::iterator,bool> 
		addReceivedSubformulaToPassedFormula
		(
		    ModuleInput::const_iterator
		)
		\end{verbatim}
		Adds the formula at the given positition in the received formula
		to the passed formulas. The mapping to its \emph{original formulas} contains
		only the set consisting of the formula at the given position in the received formula.
	\item
		\begin{verbatim}
		std::pair<ModuleInput::iterator,bool> addSubformulaToPassedFormula
		(
		    Formula*,
		    const vec_set_const_pFormula&
		)
		\end{verbatim}
		Adds the given formula to the passed formulas. It is mapped to the given sets of origins in the received formula. 
		Note, that the second argument must contain only formulas in the received formula.
	\end{itemize}
It returns a pair of a position in the passed formula and a \texttt{bool}. The \texttt{bool} is \true, if the formula at the given position in the received formula has been added to the passed formula, which is only the case, if this formula was not yet part of the 
passed formula. Then, the returned position in the passed formula points to the just added formula. Otherwise, the \texttt{bool} 
is \false and the position points to the end of the passed formula.

If, by reason of a belated removing of the according received formulas, there is no set of original formulas of a passed formula left this passed formula will be automatically removed from the backends and the passed formula. That does also mean, that if we add
a formula to the passed formula without giving any origin, the next call of \texttt{removeSubformula} of this module removes this formula from the passed formula. However, in our experience it is always possible to state the received formulas being the origins of a passed formula and it would highly improve the incremental solving performance.

The second step is really just calling \texttt{runBackends()} and processing its return value, which can be
\True, \False, or \Unknown.

\section{Auxilliary functions}
\label{sec:auxfunctions}
The \texttt{module} class provides a rich set of methods for the analysis of the implemented procedures in a module and debugging purposes. 
Besides all the printing methods, which print the contents of a member of this module to the given output stream, \smtrat helps to maintain the correctness of new modules during their development. It therefore provides methods to store formulas with their assumed satisfiability status in order
to check them belatedly by any SMT solver which is capable to parse \texttt{.smt2} files and solve
the stored formula. To be able to use the following methods, the compiler flag \texttt{SMTRAT\_DEVOPTION\_Validation}
must be activated, which can be easily achieved when using, e.g., \ccmake.

\begin{itemize}
	\item \begin{verbatim}static void addAssumptionToCheck( const X&, bool, const string& ) \end{verbatim}
		Adds the given formulas to those, which are going to be stored as an \texttt{.smt2} file,
		with the assumption that they are satisfiable, if the given Boolean argument is \true, or unsatisfiable,
		if the given Boolean argument is \false. The formulas can be passed as one of the following types (\texttt{X} can be one of the following datastructures)
		\begin{itemize}
		\item \texttt{Formula} (a single formula of any type)
		\item \texttt{ModuleInput} (the entire received or passed formula of a module)
		\item \texttt{set<const Formula*>} (a set of formulas, which is considered to be a conjunction)
		\item \texttt{set<const Constraint*>} (a set of constraints, which is considered to be a conjunction)
		\end{itemize}
		The third argument of this function is any string which helps to identify the assumption, e.g.,
		involving the name of the module and for which purpose this assumption has been made.
	\item \begin{verbatim}static void storeAssumptionsToCheck( const Manager& )\end{verbatim}
		This method stores all collected assumptions to the file \texttt{assumptions.smt2}, which can be checked
		later by any SMT solver which is capable to parse \texttt{.smt2} files and solve
		the stored formula. As this method is static, we need to pass the module's manager (\texttt{*mpManager}).
		Note that this method will be automatically called when destructing the given manager. Invoking this
		method is only reasonable, if the solving aborts directly afterwards and, hence, omits the manager's
		destructor.
	\item \begin{verbatim}void checkInfSubsetForMinimality
(
    vector<set<const Formula*>>::const_iterator,
    const string&,
    unsigned
) const 
\end{verbatim}
This method checks the infeasible subset at the given position for minimality, that is it checks whether there is a subset of it having maximally $n$ elements less while still being infeasible.
As for some approaches it is computationally to hard to provide always a minimal infeasible subset, they rather provide infeasible subsets not necessarily being minimal. This method helps 
to analyze how close the size of the encountered infeasible subsets is to a minimal one.
\item Another important feature during the development of a new module is the collection of statistics. The script \writeModule for creating a new module automatically adds a class to maintain statistics in the same folder in which the module itself is located. The members of this class store the statistics usually represented by primitive data types as integers and floats. They can be extended as one pleases and be manipulated by methods, which have also to be implemented in this class. The main contribution of \smtrat is that these statistics are later automatically collected and printed, if the command line interface is called with the option \texttt{--statistics} or \texttt{-s}.
\item If the script \writeModule for the creation of a new module is called with the option \texttt{-s}, the module has also a template parameter being a settings object. The different settings objects are stored in the settings file again in the same folder as the module is located. Each of these setting objects assigns all settings, which are usually of type \texttt{bool}, to values. The name of these objects must be of the form XYSettingsN, if the module is called XYModule and with N being preferably a positive integer. Fulfilling these requirements the settings to compile this module with can be chosen, e.g. with \ccmake, by setting the compiler flag \texttt{SMTRAT\_XY\_Settings} to N. 
The settings can then be accessed using the template parameter \texttt{Settings} of the module. If, for instance, we want to change the control flow of the implemented procedure in the new module if a setting \texttt{mySetting} is \true, we put the corresponding code block into an \texttt{if(Settings::mySettings)\{..\}} block. This methodology assures that the right control flow is chosen during compilation and, hence,  before runtime. 
\end{itemize}

