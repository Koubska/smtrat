\chapter{Embedding of a theory solver into an SMT solver}
\label{chapter:embeddingats}
In this section we show how to embed a composed theory solver according
to Chapter~\ref{chapter:composingats}, e.g., the built-in theory 
solver \texttt{NRATSolver}, into an SMT solver in order to 
extend its supported logics by NRA. Firstly, we will explain how to
create an NRA formula and, afterwards, we will the introduce the 
interfaces of the class \managerClass, which form the interfaces of
a theory solver composed by \smtrat.

\section{Constructing an NRA formula}
The class \formulaClass represents arbitrary NRA formulas, which are
defined according to the following abstract grammar.

\section{Interfaces of a theory solver composed with \smtrat}
An SMT solver can use the following interfaces:
\begin{itemize}
	\item \begin{verbatim}bool inform( const string& _constraint, bool _infix )\end{verbatim}
		Informs the theory solver about the existence of the given constraint in form of
		a string. The second argument is a flag, which indicates whether the given constraint
		is written in infix or prefix notation.
	\item \begin{verbatim}
		bool addConstraint
		(
		    const string& _constraint,
		    const bool _infix,
		    const bool _polarity
		)
		\end{verbatim}
		Adds the given constraint in form of a string to the theory solver. The second argument 
		is a flag, which indicates whether the given constraint is written in infix or prefix 
		notation. The last argument is again a flag which is \true if the constraint
		has to hold in the given form and \false if its inversion has to hold. The inversion 
		operator for a constraint simply changes its relation symbol in the following way:
		$$\begin{array}{ccc}
			= & \mapsto & \neq \\
			\neq & \mapsto & = \\
			\leq & \mapsto & > \\
			\geq & \mapsto & < \\
			< & \mapsto & \geq \\
			> & \mapsto & \leq \\
		\end{array}$$\\[2ex]
		
    \item \begin{verbatim}Answer isConsistent( )\end{verbatim}
    	Checks the so far received constraints for consistency. The answer can either be
    	\true, if the set of the so far received constraints is consistent, or 
    	\false, if it is inconsistent, and \texttt{unknown}, if the theory 
    	solver cannot reason about it.
    \item \begin{verbatim}void pushBacktrackPoint( )\end{verbatim}
    	Pushes a backtrack point to the stack of backtrack points.
    \item \begin{verbatim}void popBacktrackPoint( )\end{verbatim}
    	Pops a backtrack point from the stack of backtrack points and undoes everything
		which has been done after adding that backtrack point.
    \item \begin{verbatim}vector< vector< unsigned > > getReasons( )\end{verbatim}
    	Returns one or more reasons for the inconsistency of the constraints. A reason
    	is an infeasible subset of the so far received constraints. An element of a reason
    	is a number $i$ and means that the $i$th received constraint is an element of
    	this infeasible subset.
\end{itemize}

